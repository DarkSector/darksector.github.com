<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Pronoy Chopra's Blog]]></title>
  <link href="http://DarkSector.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://DarkSector.github.com/"/>
  <updated>2012-04-18T11:38:14+05:30</updated>
  <id>http://DarkSector.github.com/</id>
  <author>
    <name><![CDATA[Pronoy Chopra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Attempting integration with WTForms with MongoAlchemy]]></title>
    <link href="http://DarkSector.github.com/blog/attempting-integration-with-wtforms-with-mongoalchemy/"/>
    <updated>2012-04-18T10:56:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/attempting-integration-with-wtforms-with-mongoalchemy</id>
    <content type="html"><![CDATA[<p>So the forms.py looks something like this.</p>

<p>``` python forms.py
from <strong>future</strong> import with_statement</p>

<p>from flask import Flask, request, session, g, redirect, url_for, abort, \</p>

<pre><code> render_template, flash
</code></pre>

<p>from flaskext.wtf import Form, TextField, TextAreaField, \</p>

<pre><code> PasswordField, SubmitField, Required, SelectField, ValidationError, \
 RadioField
</code></pre>

<p>from foo import app
from foo import db</p>

<p>class BuilderForm(Form):</p>

<pre><code>"""Function used to create custom fields"""
field_name = TextField()
field_type = SelectField(u'Type of Field',choices=[('','')])
submit = SubmitField('Submit Information')
</code></pre>

<p>class Register(Form):</p>

<pre><code>"""Form for registeration of professional, org or moderator"""      
usertype = SelectField(u'Type of user', choices=[('org','Organization'),('pro','Professional'),('mod','Moderator')])
name = TextField('Organization/Professional Name')
email = TextField('Email addresss *')
phone = TextField('Phone Number *')
register = SubmitField('Submit user information')
</code></pre>

<p>class LoginForm(Form):</p>

<pre><code>"""Form for logging in for Professionals and Orgs"""

email = TextField('Your email which you used to register')
password = PasswordField('Your passsword')
usertype = SelectField(u'Log me in as', choices=[('org','Organization'),('pro','Professional'),('mod','Moderator')])
login = SubmitField('Login')
</code></pre>

<p>class StarterForm(Form):</p>

<pre><code>"""Form for starting off the profile display process"""
region = SelectField(u'Select you state', choices=[])
pincode = TextField("Your pincode")
specific = TextField("Town or Village")
submit = SubmitField('Submit')
</code></pre>

<p>```</p>

<p>Notice how the region field in StarterForm would require database driven choices? Yeah I need to figure out how to do that in my views function. It's important to render the views otherwise it might break the whole thing by circular imports.</p>

<p>Also since Forms are classes it would be difficult to pass the arguments when calling the form in views. Okay let's attempt that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping web based data acquisition applications]]></title>
    <link href="http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications/"/>
    <updated>2012-04-17T03:15:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications</id>
    <content type="html"><![CDATA[<p>In order to build an application that processes or even simply displays data being acquired by say the serial port, it is not important to actually have the device connected.</p>

<p>We can build virtual serial pairs and have our backend transmit and acquire dummy data and then test the processing logic. This is one of the reasons why I love Python. It just doesn't get in your way and gets you all the stuff you need to get started ASAP.</p>

<p>So I've resorted to <a href="http://pyserial.sourceforge.net/">PySerial</a> and this application called <a href="http://code.google.com/p/macosxvirtualserialport/">Virtual Serial Port</a>. The latter creates a pair in the /dev and the former is used to put in the data from one end and retrieve it at the other. An important question one could ask, why not just generate dummy data than getting it passed through a virtual serial pipe? Answer is that it's the closest way to the real thing, might as well get it done.</p>

<p>So, after having created serial ports, now to simply create two scripts that pour and retrieve data.</p>

<p>``` python Dummy-feeder.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import random
import time</p>

<p><em>portname = '/dev/master'
dumper = serial.Serial(</em>portname,115200,timeout=1)
while(1):</p>

<pre><code>l = random.randint(0,1023)
k = random.choice('abcdef')
dumper.write(k)
dumper.write(str(l))
print "random sensor:",k
print "random print: ",l 
time.sleep(2)
</code></pre>

<p>```</p>

<p>``` python Receiver.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import json</p>

<p><em>recvport = '/dev/slave'
recv = serial.Serial(</em>recvport,115200,timeout=1)
while(1):</p>

<pre><code>data = recv.readline()
print "received:", data
</code></pre>

<p>```</p>

<p>Yeah, so as it's pretty obvious, dummy feeds the data and receiver receives it and just dumps it out on STDOUT. Now, that I've got this data, I need to be able to manipulate it to be able to send it to my application server. I think I'll need the involvement of JSON here. Must experiment.</p>
]]></content>
  </entry>
  
</feed>
