<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Pronoy Chopra's Blog]]></title>
  <link href="http://DarkSector.github.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://DarkSector.github.com/"/>
  <updated>2012-05-14T12:14:14+05:30</updated>
  <id>http://DarkSector.github.com/</id>
  <author>
    <name><![CDATA[Pronoy Chopra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A pain that is a new mac]]></title>
    <link href="http://DarkSector.github.com/blog/a-pain-that-is-a-new-mac/"/>
    <updated>2012-05-11T13:26:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/a-pain-that-is-a-new-mac</id>
    <content type="html"><![CDATA[<p>Once the novelty of getting a new mac has worn off, the real trouble sets in. Configuring it. Now the worst part about developing on a Mac is the downloading of Xcode and installing it. Xcode is by far the shittiest and the most disgusting piece of software designed by Apple. Now in order to get the latest Xcode you'll need to upgrade to the latest OS. Currently it's <del>10.7.3</del> 10.7.4.</p>

<p>So to get Xcode 4.3 you need to first upgrade to <del>10.7.3</del> 10.7.4 and then go through the motions of getting Xcode first and then letting it install itself.</p>

<p>Since most of the packages need to be built, it's necessary to have GCC 4.2-llvm or clang installed and that comes only with Xcode. So till the time you get it, you can't use Machomebrew or most of the Python packages.</p>

<p><img src="http://f.cl.ly/items/2R3n1y0x2a0X1r193829/Screen%20Shot%202012-05-12%20at%201.59.43%20PM.png"></p>

<p>I guess I'll have to take this POS home and then put it on a continuous install. Thanks a lot Apple. So much for your design.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Migrating from MongoAlchemy]]></title>
    <link href="http://DarkSector.github.com/blog/migrating-from-mongoalchemy/"/>
    <updated>2012-05-02T22:59:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/migrating-from-mongoalchemy</id>
    <content type="html"><![CDATA[<p>Extensions like <a href="http://packages.python.org/Flask-MongoAlchemy/">Flask-MongoAlchemy</a> and <a href="http://flask.pocoo.org/docs/patterns/mongokit/">Flask-MongoKit</a> are probably the most useless extensions for <a href="http://flask.pocoo.org/">Flask</a> because they ignore the inherent reason why Mongo is to be used. What is the point of using <a href="http://www.mongodb.org/">MongoDB</a> when you are going to used a fix schema. A fixed model declaration should be used with RDBMS like PostGRE and SQLite by using <a href="http://www.sqlalchemy.org/">SQLAlchemy</a>.</p>

<p>I wonder why hasn't anyone come up with this question before. Either way I'll be using PyMongo now. Flask has an extension for that, it's called <a href="http://flask-pymongo.readthedocs.org/en/0-1/index.html">Flask-PyMongo</a>.</p>

<h2>MongoDB Basics</h2>

<p>Here're some interesting relations between SQL and MongoDB's way of organizing things.</p>

<table class="table table-bordered table-striped">
    <thead>
        <tr>
            <th>SQL</th>
            <th>MongoDB</th>
        </tr>   
    </thead>
    <tbody> 
        <tr>
            <td>Database</td>
            <td>Database</td>
        </tr>
        <tr>
            <td>Table</td>
            <td>Collection</td>
        </tr>
        <tr>
            <td>Row</td>
            <td>Document</td>
        </tr>
        <tr>
            <td>Index</td>
            <td>Index</td>
        </tr>
        <tr>
            <td>Primary key</td>
            <td>_id field</td>
        </tr>
    </tbody>
</table>


<p>A complete list of relations is given in the mapping chart over at <a href="http://www.mongodb.org/display/DOCS/SQL+to+Mongo+Mapping+Chart">MongoDB's website</a></p>

<p>This is neat considering you don't need any fixed schema, just stash the data in and you can easily recover it. So now instead of using MongoAlchemy we will be using PyMongo directly which is fairly easy as well.</p>

<h2>Why Mongo with Python makes sense</h2>

<p>Python Dicts and Mongo's BSON documents are just the same. So passing dicts as documents is fairly intuitive. Here's a comparison:</p>

<p>```python dict.py</p>

<blockquote><blockquote><blockquote><p>a = {"a" : "b", "c" : "d", "k" : 3}
```</p></blockquote></blockquote></blockquote>

<p>```javascript MongoDB schema example
{
  _id : ObjectId("4e77bb3b8a3e000000004f7a"),
  when : Date("2011-09-19T02:10:11.3Z",
  author : "alex",
  title : "No Free Lunch",
  text : "This is the text of the post.  It could be very long.",
  tags : [ "business", "ramblings" ],
  votes : 5,
  voters : [ "jane", "joe", "spencer", "phyllis", "li" ],
  comments : [</p>

<pre><code>{ who : "jane", when : Date("2011-09-19T04:00:10.112Z"),
  comment : "I agree." },
{ who : "meghan", when : Date("2011-09-20T14:36:06.958Z"),
  comment : "You must be joking.  etc etc ..." }
</code></pre>

<p>  ]
}
```</p>

<p>It's similar and therefore easier.</p>

<h2>PyMongo Usage</h2>

<p><code>bash  start the mongo daemon on any port and application directory to store database
$ mongod --port 45000 --dbpath $PATHTOAPPLICATIONDIRECTORY
</code></p>

<p>```python</p>

<h1>import pymongo and make the connection</h1>

<p>from pymongo import Connection</p>

<h1>connect it to the mongo daemon running on the port</h1>

<p>connection = Connection('localhost', 45000)
```</p>

<p>After that we'll need to start creating databases and collections and inserting documents, I'll post the code later when I am done with general implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Attempting integration with WTForms with MongoAlchemy]]></title>
    <link href="http://DarkSector.github.com/blog/attempting-integration-with-wtforms-with-mongoalchemy/"/>
    <updated>2012-04-18T10:56:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/attempting-integration-with-wtforms-with-mongoalchemy</id>
    <content type="html"><![CDATA[<p>So the forms.py looks something like this.</p>

<p>``` python forms.py
from <strong>future</strong> import with_statement</p>

<p>from flask import Flask, request, session, g, redirect, url_for, abort, \</p>

<pre><code> render_template, flash
</code></pre>

<p>from flaskext.wtf import Form, TextField, TextAreaField, \</p>

<pre><code> PasswordField, SubmitField, Required, SelectField, ValidationError, \
 RadioField
</code></pre>

<p>from foo import app
from foo import db</p>

<p>class BuilderForm(Form):</p>

<pre><code>"""Function used to create custom fields"""
field_name = TextField()
field_type = SelectField(u'Type of Field',choices=[('','')])
submit = SubmitField('Submit Information')
</code></pre>

<p>class Register(Form):</p>

<pre><code>"""Form for registeration of professional, org or moderator"""      
usertype = SelectField(u'Type of user', choices=[('org','Organization'),('pro','Professional'),('mod','Moderator')])
name = TextField('Organization/Professional Name')
email = TextField('Email addresss *')
phone = TextField('Phone Number *')
register = SubmitField('Submit user information')
</code></pre>

<p>class LoginForm(Form):</p>

<pre><code>"""Form for logging in for Professionals and Orgs"""

email = TextField('Your email which you used to register')
password = PasswordField('Your passsword')
usertype = SelectField(u'Log me in as', choices=[('org','Organization'),('pro','Professional'),('mod','Moderator')])
login = SubmitField('Login')
</code></pre>

<p>class StarterForm(Form):</p>

<pre><code>"""Form for starting off the profile display process"""
region = SelectField(u'Select you state', choices=[])
pincode = TextField("Your pincode")
specific = TextField("Town or Village")
submit = SubmitField('Submit')
</code></pre>

<p>```</p>

<p>Notice how the region field in StarterForm would require database driven choices? Yeah I need to figure out how to do that in my views function. It's important to render the views otherwise it might break the whole thing by circular imports.</p>

<p>Also since Forms are classes it would be difficult to pass the arguments when calling the form in views. Okay let's attempt that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping web based data acquisition applications]]></title>
    <link href="http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications/"/>
    <updated>2012-04-17T03:15:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications</id>
    <content type="html"><![CDATA[<p>In order to build an application that processes or even simply displays data being acquired by say the serial port, it is not important to actually have the device connected.</p>

<p>We can build virtual serial pairs and have our backend transmit and acquire dummy data and then test the processing logic. This is one of the reasons why I love Python. It just doesn't get in your way and gets you all the stuff you need to get started ASAP.</p>

<p>So I've resorted to <a href="http://pyserial.sourceforge.net/">PySerial</a> and this application called <a href="http://code.google.com/p/macosxvirtualserialport/">Virtual Serial Port</a>. The latter creates a pair in the /dev and the former is used to put in the data from one end and retrieve it at the other. An important question one could ask, why not just generate dummy data than getting it passed through a virtual serial pipe? Answer is that it's the closest way to the real thing, might as well get it done.</p>

<p>So, after having created serial ports, now to simply create two scripts that pour and retrieve data.</p>

<p>``` python Dummy-feeder.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import random
import time</p>

<p><em>portname = '/dev/master'
dumper = serial.Serial(</em>portname,115200,timeout=1)
while(1):</p>

<pre><code>l = random.randint(0,1023)
k = random.choice('abcdef')
dumper.write(k)
dumper.write(str(l))
print "random sensor:",k
print "random print: ",l 
time.sleep(2)
</code></pre>

<p>```</p>

<p>``` python Receiver.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import json</p>

<p><em>recvport = '/dev/slave'
recv = serial.Serial(</em>recvport,115200,timeout=1)
while(1):</p>

<pre><code>data = recv.readline()
print "received:", data
</code></pre>

<p>```</p>

<p>Yeah, so as it's pretty obvious, dummy feeds the data and receiver receives it and just dumps it out on STDOUT. Now, that I've got this data, I need to be able to manipulate it to be able to send it to my application server. I think I'll need the involvement of JSON here. Must experiment.</p>
]]></content>
  </entry>
  
</feed>
