<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: AVR | Pronoy Chopra's Blog]]></title>
  <link href="http://DarkSector.github.com/blog/categories/avr/atom.xml" rel="self"/>
  <link href="http://DarkSector.github.com/"/>
  <updated>2012-09-21T18:50:45+05:30</updated>
  <id>http://DarkSector.github.com/</id>
  <author>
    <name><![CDATA[Pronoy Chopra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Arduino IR code: updated]]></title>
    <link href="http://DarkSector.github.com/blog/arduino-ir-code-updated/"/>
    <updated>2012-06-26T13:34:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/arduino-ir-code-updated</id>
    <content type="html"><![CDATA[<p>Here's my updated Arduino code that I wrote to go with the protoshield by <a href="http://www.9circuits.com">9circuits</a> and the relay shield connected to the protoshield.</p>

<p><img src="http://arduino.cc/en/uploads/Main/ArduinoUno_r2_front450px.jpg"></p>

<p>```obj-c ArduinoIR.cpp
int RECV_PIN = 11;
int relay2 = 7;
int relay1 = 6;
long vol_down = 948321226;
long vol_up = 948321218;</p>

<p>boolean relay1_FLAG = false;
boolean relay2_FLAG = false;</p>

<h1>include &lt;IRremote.h></h1>

<p>IRrecv irrecv(RECV_PIN);</p>

<p>decode_results results;</p>

<p>void setup()
{
  Serial.begin(9600);
  irrecv.enableIRIn();
  pinMode(relay1,OUTPUT);
  pinMode(relay2,OUTPUT);</p>

<p>}</p>

<p>void check_val_execute(long a) {
  if (a == vol_down) {</p>

<pre><code>if (relay1_FLAG) {
  light1_on();
  relay1_FLAG = !(relay1_FLAG);

}
else {
  light1_off();
  relay1_FLAG = !(relay1_FLAG);
}  
</code></pre>

<p>  }</p>

<p>  else if (a == vol_up){</p>

<pre><code>if (relay2_FLAG) {
  light2_on();
  relay2_FLAG = !(relay2_FLAG);
}

else {
  light2_off();
  relay2_FLAG = !(relay2_FLAG);
}  
</code></pre>

<p>  }
}</p>

<p>void light1_on() {
  digitalWrite(relay1,HIGH);
}</p>

<p>void light2_on() {
  digitalWrite(relay2,HIGH);
}</p>

<p>void light1_off() {
  digitalWrite(relay1,LOW);
}</p>

<p>void light2_off() {
  digitalWrite(relay2,LOW);
}</p>

<p>void loop()
{
  if (irrecv.decode(&amp;results)) {</p>

<pre><code>//Serial.println(results.value, DEC);
delay(300);
irrecv.resume();
long x = results.value;
check_val_execute(x);
</code></pre>

<p>  }
}
```</p>

<p>No comments yet, I'll do that later.r</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVR Assembly revisted]]></title>
    <link href="http://DarkSector.github.com/blog/avr-assembly/"/>
    <updated>2012-05-23T23:22:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/avr-assembly</id>
    <content type="html"><![CDATA[<p>Assembly for AVR is really interesting. Back in college I wrote a number of programs and I've been going over them again. This is some of the code.</p>

<p><div><script src='https://gist.github.com/2776751.js?file='></script>
<noscript><pre><code>.ORG 0

;STACK POINTER SET
LDI R16, HIGH(RAMEND)
OUT SPH, R16
LDI R16, LOW(RAMEND)
OUT SPL, R16


MAIN:
LDI R16, 0xFF
OUT DDRC, R16

BACK:
COM R16
OUT PORTC, R16
CALL DELAY
RJMP BACK

DELAY:
LDI R17, 100
LOOP3: LDI R18, 255
LOOP2: LDI R19, 255
LOOP1: DEC R19
BRNE LOOP1
DEC R18
BRNE LOOP2
DEC R17
BRNE LOOP3
RET</code></pre></noscript></div>
</p>

<p>I have 8 LEDs connected from D0 to D7 on PORTC and they are in the source configuration. 0xFF makes them light up and 0x00 shuts them down. So this is the blinky for you.</p>

<p>Now the DELAY function can only be called if the STACKPOINTER is set. The first few lines after .ORG do just that. Now I'll be working on timer and interrupts but first I'll put in some more code for simple things like adding 16 bit numbers etc.</p>
]]></content>
  </entry>
  
</feed>
