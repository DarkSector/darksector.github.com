<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hardware | Pronoy Chopra's Blog]]></title>
  <link href="http://DarkSector.github.com/blog/categories/hardware/atom.xml" rel="self"/>
  <link href="http://DarkSector.github.com/"/>
  <updated>2012-05-05T23:02:33+05:30</updated>
  <id>http://DarkSector.github.com/</id>
  <author>
    <name><![CDATA[Pronoy Chopra]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[First steps in programming an AVR]]></title>
    <link href="http://DarkSector.github.com/blog/first-steps-in-programming-an-avr/"/>
    <updated>2012-05-05T22:20:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/first-steps-in-programming-an-avr</id>
    <content type="html"><![CDATA[<p>So, this has been due for a long time now. First programs on how to program the AVR. If you don't know what that is, you need to google ATMEL AVR. If you know what that is, great!</p>

<p>I am going to be using an ATMega32 with an external crystal with 16MHz clock. I have a MKII programmer that allows me to use AVR Studio with it. It's the first use of Windows in programming I've found, ever. AVR Studio, rest everything is shite.</p>

<p>I am currently on Mac OS X so I need to use AVR-GCC for this which can be obtained as a crosspack from Objective Development or Ob-dev as we know them. Really cool people. I'll be later using AVRDUDE to actually burn the chip. I'll share the circuit later.</p>

<p>First, let's code.</p>

<p>```objc blinky.c</p>

<h1>define F_CPU 16000000UL</h1>

<p>//defines the clock being used, for calculating delay</p>

<h1>include &lt;inttypes.h></h1>

<h1>include &lt;avr/io.h></h1>

<h1>include &lt;util/delay.h></h1>

<p>//this is the delay function included here</p>

<p>int main(){</p>

<pre><code>DDRC |= 0xFF;
//set the data direction registers of PORTC as output, all of them.

while(1){

    PORTC |= 0xFF;
    //write the value 255 or FF in hex so that all LEDs may light up
    //or go out as per your LED configuration

    _delay_ms(100);
    //this is for providing delay of 100 milliseconds

    PORTC = ~PORTC;
    //just negate the last value on PORTC, so it toggles the values and
    //hence the LEDs

    _delay_ms(100);
    //This delay is necessary, you'll have to run the program to understand
    //why

}
return 0;
//return 0 because main is int type
</code></pre>

<p>}
```</p>

<p>So, this is the basic AVR C program. Let's compile it. But compiling is not enough, we want a .hex file that we'll eventually burn on the chip's Flash ROM. But luckily we can produce that from the .elf we'll create. This is how it's done.</p>

<p><code>bash avr-gcc commands to compile blinky.c
$ avr-gcc -g -Os -mmcu=atmega32 -c blinky.c
$ avr-gcc -g -mmcu=atmega32 -o blinky.c blinky.o
$ avr-objcopy -j .text -j .data -O ihex blinky.elf blinky.hex
</code></p>

<p>So now we have the blinky.hex, let's burn it to the chip. I'll be using AVRDUDE as I mentioned before. Here's the one command that solves our problem</p>

<p><code>bash avrdude
avrdude -F -c avrispmkII -p m32 -P /dev/ttyUSB0 -b 19200 -U flash:w:$filename".hex" -e -vv
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping web based data acquisition applications]]></title>
    <link href="http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications/"/>
    <updated>2012-04-17T03:15:00+05:30</updated>
    <id>http://DarkSector.github.com/blog/prototyping-web-based--data-acquisition-applications</id>
    <content type="html"><![CDATA[<p>In order to build an application that processes or even simply displays data being acquired by say the serial port, it is not important to actually have the device connected.</p>

<p>We can build virtual serial pairs and have our backend transmit and acquire dummy data and then test the processing logic. This is one of the reasons why I love Python. It just doesn't get in your way and gets you all the stuff you need to get started ASAP.</p>

<p>So I've resorted to <a href="http://pyserial.sourceforge.net/">PySerial</a> and this application called <a href="http://code.google.com/p/macosxvirtualserialport/">Virtual Serial Port</a>. The latter creates a pair in the /dev and the former is used to put in the data from one end and retrieve it at the other. An important question one could ask, why not just generate dummy data than getting it passed through a virtual serial pipe? Answer is that it's the closest way to the real thing, might as well get it done.</p>

<p>So, after having created serial ports, now to simply create two scripts that pour and retrieve data.</p>

<p>``` python Dummy-feeder.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import random
import time</p>

<p><em>portname = '/dev/master'
dumper = serial.Serial(</em>portname,115200,timeout=1)
while(1):</p>

<pre><code>l = random.randint(0,1023)
k = random.choice('abcdef')
dumper.write(k)
dumper.write(str(l))
print "random sensor:",k
print "random print: ",l 
time.sleep(2)
</code></pre>

<p>```</p>

<p>``` python Receiver.py</p>

<h1>!/usr/bin/python</h1>

<p>import serial
import json</p>

<p><em>recvport = '/dev/slave'
recv = serial.Serial(</em>recvport,115200,timeout=1)
while(1):</p>

<pre><code>data = recv.readline()
print "received:", data
</code></pre>

<p>```</p>

<p>Yeah, so as it's pretty obvious, dummy feeds the data and receiver receives it and just dumps it out on STDOUT. Now, that I've got this data, I need to be able to manipulate it to be able to send it to my application server. I think I'll need the involvement of JSON here. Must experiment.</p>
]]></content>
  </entry>
  
</feed>
